rules_version = '2';
service cloud.firestore {
  match /databases/{database}/documents {
    
    // 🛡️ Tasks Collection - Production Security Rules
    match /tasks/{taskId} {
      // Only authenticated users can access their own tasks
      allow read, write: if request.auth != null 
        && request.auth.uid == resource.data.userId;
      allow create: if request.auth != null 
        && request.auth.uid == request.resource.data.userId
        && validateTask(request.resource.data);
      allow delete: if request.auth != null 
        && request.auth.uid == resource.data.userId;
    }
    
    // 🛡️ User Profiles + Sub-Collections - Production Security
    match /users/{userId} {
      // Only authenticated users can access their own profile
      allow read, write: if request.auth != null 
        && request.auth.uid == userId
        && validateUserAccess(userId);
      allow create: if request.auth != null 
        && request.auth.uid == userId;
      
      // 💬 Chat Sessions Sub-Collection
      match /chat_sessions/{sessionId} {
        // Only user can access their own sessions
        allow read, write: if request.auth != null 
          && request.auth.uid == userId
          && validateUserAccess(userId);
        allow create: if request.auth != null 
          && request.auth.uid == userId
          && validateChatSession(request.resource.data)
          && validateUserAccess(userId);
        allow delete: if request.auth != null 
          && request.auth.uid == userId;
        
        // 📨 Chat Messages Sub-Sub-Collection
        match /messages/{messageId} {
          allow read, write: if request.auth != null 
            && request.auth.uid == userId
            && validateUserAccess(userId);
          allow create: if request.auth != null 
            && request.auth.uid == userId
            && validateChatMessage(request.resource.data)
            && validateUserAccess(userId);
          allow delete: if request.auth != null 
            && request.auth.uid == userId;
        }
      }
      
      // 📨 Chat Messages Sub-Collection (Direct)
      match /chat_messages/{messageId} {
        allow read, write: if request.auth != null 
          && request.auth.uid == userId
          && validateUserAccess(userId);
        allow create: if request.auth != null 
          && request.auth.uid == userId
          && validateChatMessage(request.resource.data)
          && validateUserAccess(userId);
        allow delete: if request.auth != null 
          && request.auth.uid == userId;
      }
    }
    
    // 🛡️ Legacy Chat Messages - Production Security (for backward compatibility)
    match /chat_messages/{messageId} {
      allow read, write: if request.auth != null 
        && request.auth.uid == resource.data.userId
        && validateUserAccess(request.auth.uid);
      allow create: if request.auth != null 
        && request.auth.uid == request.resource.data.userId
        && validateChatMessage(request.resource.data)
        && validateUserAccess(request.auth.uid);
      allow delete: if request.auth != null 
        && request.auth.uid == resource.data.userId;
    }
    
    // 🚫 Deny all other access by default
    match /{document=**} {
      allow read, write: if false;
    }
  }
  
  // 🔐 Security validation functions
  function validateUserAccess(uid) {
    return request.auth != null 
      && request.auth.uid == uid
      && request.auth.token.firebase.sign_in_provider != null
      && request.time < timestamp.date(2030, 12, 31); // Token expiry safety
  }
  
  // 📝 Task validation with enhanced security
  function validateTask(task) {
    return task.keys().hasAll(['title', 'completed', 'createdAt', 'updatedAt', 'userId'])
      && task.title is string
      && task.title.size() > 0
      && task.title.size() <= 200
      && task.completed is bool
      && task.userId is string
      && task.userId == request.auth.uid // Security: userId must match authenticated user
      && task.createdAt is timestamp
      && task.updatedAt is timestamp
      && task.createdAt <= request.time // Can't create tasks in the future
      && task.updatedAt <= request.time
      && (!task.keys().hasAny(['priority']) || task.priority in ['low', 'medium', 'high', 'urgent'])
      && (!task.keys().hasAny(['category']) || (task.category is string && task.category.size() <= 50))
      && (!task.keys().hasAny(['tags']) || (task.tags is list && task.tags.size() <= 10))
      && (!task.keys().hasAny(['estimatedTime']) || (task.estimatedTime is number && task.estimatedTime >= 0));
  }
  
  // 💬 Chat session validation with enhanced security
  function validateChatSession(session) {
    return session.keys().hasAll(['title', 'created_at', 'updated_at', 'status'])
      && session.title is string
      && session.title.size() > 0
      && session.title.size() <= 100
      && session.status in ['active', 'archived', 'deleted']
      && session.created_at is timestamp
      && session.updated_at is timestamp
      && session.created_at <= request.time
      && session.updated_at <= request.time
      && session.message_count is number
      && session.message_count >= 0
      && session.message_count <= 1000 // Reasonable limit
      && (!session.keys().hasAny(['last_message_at']) || session.last_message_at is timestamp)
      && (!session.keys().hasAny(['context_size']) || (session.context_size is number && session.context_size >= 0));
  }
  
  // 💬 Chat message validation with enhanced security
  function validateChatMessage(message) {
    return message.keys().hasAll(['content', 'sender', 'timestamp'])
      && message.content is string
      && message.content.size() > 0
      && message.content.size() <= 5000
      && message.sender in ['user', 'ai', 'assistant', 'system']
      && message.timestamp is timestamp
      && message.timestamp <= request.time
      && (!message.keys().hasAny(['session_id']) || message.session_id is string)
      && (!message.keys().hasAny(['type']) || message.type in ['text', 'task', 'suggestion', 'error', 'system'])
      && (!message.keys().hasAny(['metadata']) || message.metadata is map)
      && (!message.keys().hasAny(['tokens']) || (message.tokens is number && message.tokens >= 0 && message.tokens <= 10000))
      && (!message.keys().hasAny(['model']) || (message.model is string && message.model.size() <= 50));
  }
  
  // 🔒 Rate limiting helper (conceptual - actual implementation would need external service)
  function isWithinRateLimit(uid) {
    // This would typically be implemented with external rate limiting service
    // For now, we trust client-side rate limiting
    return true;
  }
}
